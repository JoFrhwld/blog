{
  "hash": "a0b3c7ea0a79ed663dda19db60351620",
  "result": {
    "markdown": "---\ntitle: \"Making a spectrogram in R\"\ndate: 2023-01-22\ncategories:\n  - \"how-to\"\n  - \"r\"\nimage: \"index_files/figure-html/fig-countour2-1.png\"\ntwitter-card: \n  image: \"index_files/figure-html/fig-countour2-1.png\"\n  card-style: summary_large_image\nopen-graph:\n  image: \"index_files/figure-html/fig-countour2-1.png\"\nknitr: \n  opts_chunk: \n    message: false\nresources: \n  - \"assets/Close_front_unrounded_vowel.wav\"\n  - \"assets/Close_front_unrounded_vowel.ogg\"\norder: 03\n---\n\n\nI might flesh this out as a more detailed tutorial for [LingMethodsHub](https://lingmethodshub.github.io/content/), but for now this is going to be a rough-around-the-edges post about making spectrograms in R. My goal will be to get as close as possible to recreating a spectrogram like you might get from Praat.\n\n![A spectrogram of the vowel /i/ generated by praat.](assets/praat.png){#fig-praat-spect fig-alt=\"A spectrogram of the vowel /i/ generated by praat.\" fig-align=\"center\" width=\"75%\"}\n\n## Pre-processing.\n\nTo keep things simple, I grabbed vowel audio clip from the [Wikipedia IPA vowel chat with audio](https://en.wikipedia.org/wiki/IPA_vowel_chart_with_audio) ([audio info and license](https://en.wikipedia.org/wiki/File:Close_front_unrounded_vowel.ogg)).\n\n<audio controls>\n\n<source src=\"assets/Close_front_unrounded_vowel.ogg\" type=\"audio/ogg\">\n\n<source src=\"assets/Close_front_unrounded_vowel.wav\" type=\"audio/wav\">\n\nYour browser does not support the audio element. </audio>\n\n<details>\n\n<summary>Explanation of a hacky thing I had to do.</summary>\n\nI know `{tuneR}` package has a `readWave()` function, and I couldn't figure out how to read in an [Oog](https://en.wikipedia.org/wiki/Ogg) file, so step 1 was converting the Oog to a wav file. Since I'm writing this in a quarto notebook, I thought I *should* be able to drop in a ```` ```{sh} ```` code chunk, but it seems like doesn't have access to my `PATH`. Long story short, that's why I've got this kind of goofy R code chunk with `system()` and the full path to sox.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(glue)\n\nsource(here::here(\"_defaults.R\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nogg_file <- \"assets/Close_front_unrounded_vowel.ogg\"\nwav_file <- \"assets/Close_front_unrounded_vowel.wav\"\nsystem(glue(\"/opt/homebrew/bin/sox {ogg_file} {wav_file}\"))\n```\n:::\n\n\n</details>\n\n## Loading the audio file\n\nThe `{seewave}` package, which I'm using to make the spectrogram, takes the sound objects created by `{tuneR}`, so that's what I'll use for reading in the audio file.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tuneR)\nlibrary(seewave)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ni_wav <- readWave(\"assets/Close_front_unrounded_vowel.wav\")\n```\n:::\n\n\nTo get a sense of what information is in the wav file, you can use `str()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(i_wav)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFormal class 'Wave' [package \"tuneR\"] with 6 slots\n  ..@ left     : int [1:26524] -2 16 42 24 33 53 56 68 51 55 ...\n  ..@ right    : num(0) \n  ..@ stereo   : logi FALSE\n  ..@ samp.rate: int 44100\n  ..@ bit      : int 16\n  ..@ pcm      : logi TRUE\n```\n:::\n:::\n\n\nSince I'm going to be zooming in to 0 to 5,000 Hz on the spectrogram, I'll downsample the audio to 10000.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni_wav_d <- downsample(i_wav, 10000)\n```\n:::\n\n\n## Computing the spectrogram\n\nThe function to compute the spectrogram is `seewave::spectro()`. Its argument names are formatted in a way I find a bit grating. A lot of them are compressed down to single characters or other abbreviations that require having the docs constantly open.\n\nAnyway, the arguments that seem most important are:\n\n`wl`\n\n:   window length in samples\n\n`wn`\n\n:   window function, defaulting to Hanning\n\n`ovlp`\n\n:   Window overlap, in percentage. That is, a 25% overlap between analysis windows should be passed to `ovlp` as `25`.\n\n### Praat defaults\n\nLet's have a look at the Praat spectrogram defaults\n\n![Praat defaults for spectrograms](assets/praat_defaults.png){#fig-praat-defaults fig-alt=\"A screenshot of the default spectrogram settings for Praat.\" fig-align=\"center\" width=\"75%\"}\n\nHere's a quick illustration of what these defaults correspond to. It takes an analysis window that's 0.005 seconds long, and moves it over time by 0.002 second increments. Also, the data coming into the analysis window is weighted by a Gaussian distribution.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Plot Code\"}\nwin_len <- 0.005\ntime_step <- 0.002\ntibble(\n  center = seq(win_len/2, 0.02, by = time_step),\n  left_edge = center - (win_len/2),\n  right_edge = center + (win_len/2),\n  win_num = seq_along(center)\n) -> window_fig\nwindow_fig |> \n  ggplot(aes(x = center, y = win_num))+\n    geom_pointrange(\n      aes(\n        xmin = left_edge,\n        xmax = right_edge\n      ),\n      size = 2,\n      linewidth = 2\n    )+\n  labs(x = \"time\",\n       y = NULL,\n       title = \"Overlapping spectrogram window illustration\")+\n  theme(axis.text.y = element_blank(),\n        panel.grid.major.y = element_blank(),\n        panel.grid.minor.y = element_blank())\n```\n\n::: {.cell-output-display}\n![An illustration of overlapping analysis windows that produce a spectrogram](index_files/figure-html/fig-windows-1.png){#fig-windows fig-alt='A figure with point ranges illustrating the overlap of spectrogram analysis windows. Each successive window overlaps by slightly more than 50' width=768}\n:::\n:::\n\n\nThe `seewave::spectro()` function defines this same relationship, except instead of the time step or window hop length, we need to define by what % the windows overlap. We also need to express how wide the windows are in terms of audio sample, rather than in terms of time, but that just requires multiplying the desired time width by the sampling rate.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwin_len <- 0.005 * i_wav_d@samp.rate\nhop_len <- 0.002 * i_wav_d@samp.rate\noverlap <- ((win_len - hop_len) / win_len) * 100\n```\n:::\n\n\nThe one thing that I can't recreate for now is the Gaussian window function. `{seewave}` doesn't have it implemented, so I'll just stick with its default (Hamming)\n\n### Computing the spectrogram\n\nNow, it's a pretty straightforward call to `spectro()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspect <-\n  i_wav_d |>\n  spectro(\n    # window length, in terms of samples\n    wl = win_len,\n    # window overlap\n    ovlp = overlap,\n    # don't plot the result\n    plot = F\n    )\n```\n:::\n\n\nThe `spect` object is a list with three named items\n\n`$time`\n\n:   a vector corresponding to the time domain\n\n`$freq`\n\n:   a vector corresponding to the frequency domain\n\n`$amp`\n\n:   a matrix of amplitudes across the time and frequency domains\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(spect)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 3\n $ time: num [1:299] 0 0.00202 0.00404 0.00606 0.00807 ...\n $ freq: num [1:25] 0 0.2 0.4 0.6 0.8 1 1.2 1.4 1.6 1.8 ...\n $ amp : num [1:25, 1:299] -35.1 -39.5 -51.3 -49.9 -51.7 ...\n```\n:::\n:::\n\n\n### Tidying up\n\nIn order to make a plot of the spectrogram in `{ggplot2}`, we need to do some tidying up. I'll go about this by setting the row and column names of the `spect$amp` matrix to the frequency and time domain values, converting it to a data frame, then doing some pivoting.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# set the colnames and rownames\ncolnames(spect$amp) <- spect$time\nrownames(spect$amp) <- spect$freq\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nspect_df <-\n  spect$amp |>\n  # coerce the row names to a column\n  as_tibble(rownames = \"freq\") |>\n  # pivot to long format\n  pivot_longer(\n    # all columns except freq\n    -freq, \n    names_to = \"time\", \n    values_to = \"amp\"\n  ) |>\n  # since they were names before,\n  # freq and time need conversion to numeric\n  mutate(\n    freq = as.numeric(freq),\n    time = as.numeric(time)\n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(spect_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      freq          time             amp        \n Min.   :0.0   Min.   :0.0000   Min.   :-89.94  \n 1st Qu.:1.2   1st Qu.:0.1494   1st Qu.:-45.17  \n Median :2.4   Median :0.3008   Median :-35.85  \n Mean   :2.4   Mean   :0.3008   Mean   :-35.43  \n 3rd Qu.:3.6   3rd Qu.:0.4521   3rd Qu.:-26.69  \n Max.   :4.8   Max.   :0.6015   Max.   :  0.00  \n```\n:::\n:::\n\n\n### \"Dynamic Range\"\n\nFrequency data is represented in terms of kHz, which I'll leave alone for now. One last thing we need to re-recreate from Praat is the \"dynamic range\". All values below some cut off (by default, 50 below the maximum) are plotted with the same color. We can do that with some data frame operations here.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndyn = -50\nspect_df_floor <- \n  spect_df |> \n  mutate(\n    amp_floor = case_when(\n      amp < dyn ~ dyn,\n      TRUE ~ amp  \n    )\n  )\n```\n:::\n\n\n## Plotting the spectrogram\n\nNow what's left is to plot the thing. I'll load the `{khroma}` package in order to get some nice color scales.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(khroma)\n```\n:::\n\n\n### Basic raster plot\n\nAs a first step, we can plot the time by frequency data as a raster plot, with little rectangles for each position filled in with their amplitude.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspect_df_floor |> \n  ggplot(aes(time, freq))+\n    geom_raster(aes(fill = amp_floor))+\n    guides(fill = \"none\")+\n    labs(\n      x = \"time (s)\",\n      y = \"frequency (kHz)\",\n      title = \"spectrogram raster plot\"\n    )\n```\n\n::: {.cell-output-display}\n![A raster spectrogram plot](index_files/figure-html/fig-raster-1.png){#fig-raster fig-alt='A spectrogram, drawn as a raster plot' width=576}\n:::\n:::\n\n\n### Spectrogram contour plot\n\nTo get closer to the Praat output, though, we need to make a contour plot instead. Here's where I'm getting a bit stymied. I wind up with these weird diagonal \"shadows\" on the right and left hand side of the spectrogram, which I think are a result of how the `stat_contour()` is being computed and plotted, rather than anything to do with the actual spectrogram.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspect_df_floor |> \n  ggplot(aes(time, freq))+\n    stat_contour(\n      aes(\n        z = amp_floor,\n        fill = after_stat(level)\n      ),\n      geom = \"polygon\",\n      bins = 300\n    )+\n    scale_fill_batlow()+\n    guides(fill = \"none\")+\n    labs(\n      x = \"time (s)\",\n      y = \"frequency (kHz)\",\n      title = \"spectrogram contour plot\"\n    )\n```\n\n::: {.cell-output-display}\n![A contour spectrogram plot](index_files/figure-html/fig-countour1-1.png){#fig-countour1 fig-alt='A spectrogram, drawn with contours' width=576}\n:::\n:::\n\n\nOne way around this I've found is to compute the spectrogram on the higher sampling rate audio, and then zoom into the frequency range you want.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"re-running the spectrogram\"}\nwin_len <- 0.005 * i_wav@samp.rate\nhop_len <- 0.002 * i_wav@samp.rate\noverlap <- ((win_len - hop_len) / win_len) * 100\n\nspect2 <-\n  i_wav |>\n  spectro(\n    # window length, in terms of samples\n    wl = win_len,\n    # window overlap\n    ovlp = overlap,\n    # don't plot the result\n    plot = F\n    )\n\n# set the colnames and rownames\ncolnames(spect2$amp) <- spect2$time\nrownames(spect2$amp) <- spect2$freq\n\nspect2_df <-\n  spect2$amp |>\n  # coerce the row names to a column\n  as_tibble(rownames = \"freq\") |>\n  # pivot to long format\n  pivot_longer(\n    # all columns except freq\n    -freq, \n    names_to = \"time\", \n    values_to = \"amp\"\n  ) |>\n  # since they were names before,\n  # freq and time need conversion to numeric\n  mutate(\n    freq = as.numeric(freq),\n    time = as.numeric(time)\n  )\n\ndyn = -50\nspect2_df_floor <- \n  spect2_df |> \n  mutate(\n    amp_floor = case_when(\n      amp < dyn ~ dyn,\n      TRUE ~ amp  \n    )\n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nspect2_df_floor |> \n  ggplot(aes(time, freq))+\n    stat_contour(\n      aes(\n        z = amp_floor,\n        fill = after_stat(level)\n      ),\n      geom = \"polygon\",\n      bins = 300\n    )+\n    scale_fill_batlow()+\n    guides(fill = \"none\")+\n    labs(\n      x = \"time (s)\",\n      y = \"frequency (kHz)\",\n      title = \"spectrogram contour plot\"\n    )+\n    coord_cartesian(ylim = c(0, 5))\n```\n\n::: {.cell-output-display}\n![A contour spectrogram plot](index_files/figure-html/fig-countour2-1.png){#fig-countour2 fig-alt='A spectrogram, drawn with contours' width=576}\n:::\n:::\n\n\nI think this might not be necessary if I had a better handle on `stat_contour()` but for now, it does the trick!\n\n## Update\n\nDue to popular request, another attempt at showing the degree of window overlap.\n\n<blockquote class=\"twitter-tweet\" data-conversation=\"none\" data-dnt=\"true\" data-theme=\"dark\">\n\n<p lang=\"en\" dir=\"ltr\">\n\nThis is fantastic, jo, thx! One quick q, I'm wondering if there might be a better way to visualize overlapping windows. The image maybe implies some y dimension (windows increasing in some vertical space). I'm just putting myself in a 1st yrs shoes in my speech class\n\n</p>\n\n--- Chandan (@GutStrings) <a href=\"https://twitter.com/GutStrings/status/1617251839749279745?ref_src=twsrc%5Etfw\">January 22, 2023</a>\n\n</blockquote>\n\n\n```{=html}\n<script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n```\n\nI've folded the code here, just because it's medium gnarly. The short version is you can get the weights for the window functions from `seewave::ftwindow()`, and then I used `geom_area()` to plot it.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"the data and plotting code\"}\nwindow_fig |> \n  group_by(win_num) |> \n  nest() |> \n  mutate(\n    dists = map(\n      data, \n      \\(df){\n        tibble(\n          time = seq(df$left_edge, df$right_edge, len = 512),\n          weight = ftwindow(512)\n        )\n      }\n    )\n  ) |> \n  unnest(dists) -> window_weights\n\nwindow_weights |> \n  ggplot(aes(time, weight, group = win_num)) +\n    geom_area(\n      aes(\n        group = win_num, \n        fill = win_num,\n        color = win_num\n      ), \n      position = \"identity\", \n      alpha = 0.5)+\n    scale_fill_hawaii(guide = \"none\")+\n    scale_color_hawaii(guide = \"none\")+\n  labs(title = \"Hamming window functions\",\n       subtitle = \"window length = 0.005, time step =0.002\")\n```\n\n::: {.cell-output-display}\n![Hamming window functions](index_files/figure-html/fig-window-dist-1.png){#fig-window-dist fig-alt='A sequence of Hamming window functions across the time domain, each overlapping with the previous by 60%' width=768}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}