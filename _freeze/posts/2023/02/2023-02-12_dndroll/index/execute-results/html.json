{
  "hash": "905b544d690499982c715f899f54028b",
  "result": {
    "markdown": "---\ntitle: \"Simulating DND Rolls\"\ndate: 2023-02-12\norder: 12\nimage: \"index_files/figure-html/fig-rollprob-1.png\"\ntwitter-card: \n  image: \"index_files/figure-html/fig-rollprob-1.png\"\n  card-style: summary_large_image\nopen-graph:\n  image: \"index_files/figure-html/fig-rollprob-1.png\"\n---\n\n\nI've recently started playing Dungeons and Dragons, and have been really enjoying the campaign my sibling runs. I'm still getting a handle on the mechanics, especially in combat, where the sequence of events that are allowed, and keeping track of your what you roll when is still a little confusing to me. Even though it's not playing out in real time, it *feels* urgent, and I don't always keep track of things like \"Am I rolling with advantage?\", \"Do I have bardic inspiration\" etc.\n\nBut in the time in between sessions, in addition to thinking through the mechanics to remember, I've also been thinking about the probabilities of it all. And what do you know! There's an R package for that: [`{droll}`](https://curso-r.github.io/droll/) !\n\n## Simulating rolls\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(geomtextpath)\nlibrary(khroma)\nlibrary(droll)\n```\n:::\n\n\nThe `{droll}` package works seems to be explicitly built to compatible with the DnD directions work. For example, you might roll a 20 sided die, or a \"d20\", and add an ability \"modifier\" to the result. In droll commands, we'll create a d20, set a dexterity modifier, then roll a random value then add that modifier:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\" code-summary=\"Setting a random seed\"}\nset.seed(12)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# make a d20\nd20 <- d(20)\n# low dex\ndex <- 1\nd20 + dex\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\nAnother thing you might do is roll multiple dice, then add the result together. For example \"roll 3d8\" means you roll three 8-sided dice, then add the result together for *something* to happen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd8 <- d(8)\n3 * d8\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 17\n```\n:::\n:::\n\n\n## Distributions\n\nIt also comes with a few probability distributions built to get the density, cumulative probability, and quantiles of die, which might already be familiar to some R users. Here's the density distributions of rolling 1, 2, 3, and 4 d8s.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## A function to make a tibble\n## of n rolls of a die.\nmake_roll_tibble <- function(n, die){\n  nfaces <- max(die@faces)\n  tibble(\n    rolls = n:(n*nfaces),\n    faces = nfaces,\n    density = droll(rolls, n*die)\n  )\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Constructing the roll densities\ntibble(n = 1:4) |> \n  mutate(\n    roll_df = map(\n      n,\n      # new R anonymous function\n      \\(n) make_roll_tibble(n, d8)\n    )\n  ) |> \n  unnest(roll_df) -> \n  roll_densities\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## plotting the roll densities\nroll_densities |> \n  mutate(\n    nd = str_c(n, \"d\", faces)\n  ) |> \n  ggplot(aes(rolls, density))+\n    geom_area(fill = \"grey90\")+\n    expand_limits(x = 1)+\n    facet_wrap(\n      ~nd, \n      scales = \"free_x\"\n      )+\n  labs(\n    title = \"Density distributions of 1 through 4 d8 rolls\"\n  )\n```\n\n::: {.cell-output-display}\n![Density distributions of nd8 rolls](index_files/figure-html/fig-rolldens-1.png){#fig-rolldens fig-align='center' fig-alt='Density plots of 1, 2, 3 and 4 d8 rolls. 1d8 is a uniform distribution, while 4d8 is approaching a normal distribution' width=576}\n:::\n:::\n\n\n## Advantage vs Disadvantage\n\nOne mechanic in DnD is rolling with \"Advantage\" vs rolling with \"Disadvantage\". If you have advantage (say, because an enemy is restrained), you roll two d20s and take the highest value. If you roll with disadvantage (say, because *you* are restrained), you roll two d20s and take the lowest value.\n\nThere's not a straightforward way to get the advantage vs disadvantage rolls, but I figured out a way to do with with some tidyverse tricks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Set up the number of rolls\nnsims = 10000\nnrolls = nsims * 2\n\n## Initial tibble with \n## random rolls\ntibble(\n  roll_id = 0:(nrolls-1),\n  roll_value = rroll(nrolls, d20)\n) |> \n  ## convert to roll groups\n  mutate(\n    roll_group = floor(roll_id/2)\n  ) |> \n  ## group\n  group_by(roll_group) |> \n  ## number the rolls\n  mutate(\n    roll_num = row_number()\n  ) |> \n  ## Get advantage, \n  ## disadvantage\n  ## and first roll\n  summarise(\n    advantage = max(roll_value),\n    disadvantage = min(roll_value),\n    normal = roll_value[1]\n  ) -> \n  simulated_rolls\n\nhead(simulated_rolls)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n  roll_group advantage disadvantage normal\n       <dbl>     <dbl>        <dbl>  <dbl>\n1          0        12            3     12\n2          1        16            2     16\n3          2        17            5     17\n4          3        16           12     16\n5          4         8            2      2\n6          5        11            1      1\n```\n:::\n:::\n\n\nNext step is to count up how many of each value we got, which requires pivoting.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimulated_rolls |> \n  pivot_longer(\n    cols = advantage:normal,\n    names_to = \"roll_type\",\n    values_to = \"roll_value\"\n  ) ->\n  rolls_long\n\nhead(rolls_long)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n  roll_group roll_type    roll_value\n       <dbl> <chr>             <dbl>\n1          0 advantage            12\n2          0 disadvantage          3\n3          0 normal               12\n4          1 advantage            16\n5          1 disadvantage          2\n6          1 normal               16\n```\n:::\n:::\n\n\nAfter pivoting long, I'll calculate the cumulative probability that a player will pass the skill check.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrolls_long |> \n  count(roll_type, roll_value) |> \n  arrange(desc(roll_value)) |> \n  mutate(\n    .by = roll_type,\n    prob = cumsum(n)/sum(n)\n  )  -> \n  check_prob\nhead(check_prob)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n  roll_type    roll_value     n   prob\n  <chr>             <dbl> <int>  <dbl>\n1 advantage            20   979 0.0979\n2 disadvantage         20    31 0.0031\n3 normal               20   515 0.0515\n4 advantage            19   884 0.186 \n5 disadvantage         19    86 0.0117\n6 normal               19   503 0.102 \n```\n:::\n:::\n\n\nLast thing to do is make a plot!\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncheck_prob |> \n  ggplot(aes(roll_value, prob, color = roll_type))+\n    geom_textpath(\n      aes(label = roll_type),\n      linewidth = 2\n    )+\n    scale_x_continuous(\n      breaks = c(5, 10, 15, 20),\n      minor_breaks = c(\n        1:4,\n        6:9,\n        11:14,\n        16:19\n      )\n    )+\n    scale_color_manual(\n      values = c(\"#b59e54\", \"#AB6dac\",\"#c73032\" )\n    )+\n    guides(\n      color = \"none\"\n    )+\n    labs(\n      title = \"Probability of passing a skill check, no modifier\",\n      x = \"Difficulty class\"\n    )\n```\n\n::: {.cell-output-display}\n![Cumulative probability density functions](index_files/figure-html/fig-rollprob-1.png){#fig-rollprob fig-align='center' fig-alt='A line graph showing the inverse cumulative density distributions of rolling a d20 normally, with advantage, and with disadvantage. Normal rolls are a straight, decreasing line. Advantage arcs over the normal rolls, while disadvantage arcs underneath it.' width=576}\n:::\n:::\n\n\n## Closing thoughts\n\nOne thought I had, while writing this post, was how the different reasons for doing these dice rolls in the game affected the kind probability plot I made. Most often you'll be rolling 3d8 in order to calculate how much damage you're going to do, so for that plot what you want to know what the point probabilities of each outcome is, hence the density functions.\n\nFor rolling d20s with advantage or disadvantage, you're wanting to see what the probability is that you'll pass the skill check, that is, that you'll roll *at least* some value, hence the inverse cumulative probability distributions!\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}