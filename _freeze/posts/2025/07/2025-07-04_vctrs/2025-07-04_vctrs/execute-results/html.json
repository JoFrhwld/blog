{
  "hash": "8c684853eb7a59c93f9c4e5841d24503",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Live blog: Implementing a vctr\"\ndate: 2025-07-04\nformat: html\neditor: visual\ndraft: true\n---\n\n::: {.callout-note .column-margin collapse=\"false\"}\n## Libraries\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(here::here(\"_defaults.R\"))\nlibrary(tidyverse)\nlibrary(rlang)\nlibrary(cli)\nlibrary(vctrs)\nlibrary(tidynorm)\n```\n:::\n\n:::\n\nRather a fully fleshed out post, I thought I'd make a \"live blog\" about me noodling around with the `{vctrs}` package, which lets you define custom vector classes.\n\n# A DCT vector\n\nI've been posting about [the Discrete Cosine Transform](../../06/2025-06-17_dct-in-tidynorm/), so maybe that's where I'll start.\nFirst, I'll grab some DCT coefficients to work with.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspeaker_tracks |> \n  nest(\n    .by = c(speaker, id)\n  ) |> \n  mutate(\n    dcts = map(data, ~dct(.x$F1)[1:5])\n  ) |> \n  pull(dcts)->\n  dcts\n\ndcts[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 495.277326 -21.891001  57.284753   8.105410  -5.455812\n```\n\n\n:::\n:::\n\n\n## The constructor and convenience functions\n\n[The main vctrs vignette](https://vctrs.r-lib.org/articles/s3-vector.html) suggests defining a constructor function and a convenience function for your custom vector.\nI think I want to treat these coefficient vectors as having paired coefficient values and coefficient indices, along with an \"order\" attribute.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# constructor function\nnew_dct_coef <- function(\n    x = double(),\n    order = integer(),\n    .call = caller_env()\n){\n  # a whole bunch of checks\n  if (!is.double(x)) {\n    cli_abort(\n      \"{.arg x} should be a {.cls double} vector.\", \n      call = .call\n    )\n  }\n  \n  if (!is.integer(order)) {\n    cli_abort(\n      \"{.arg order} should be an {.cls integer}\",\n      call = .call\n    )\n  }\n  \n  if (vec_size(order) > 1) {\n    cli_abort(\n      \"{.arg order} should be of length no greater than 1.\",\n      call = .call\n    )\n  }\n  \n  if (vec_size(x) > 0 & vec_size(order) < 1){\n    cli_abort(\n      \"{.arg order} must be provided.\"\n    )\n  }\n  \n  if (vec_size(x) > 0) {\n    if(vec_size(x) != order){\n      cli_abort(\n        c(\n          \"{.arg x} should have same length as value of {.arg order}\",\n          \"*\" = \"length of {.arg x} = {.val {vec_size(x)}}\",\n          \"*\" = \"{.arg order} = {.val {order}}\"\n        ),\n        call = .call\n      )\n    }\n  }\n  \n  \n  out <- new_rcrd(\n    fields = list(\n      x = x,\n      param = seq_along(x)\n    ),\n    class = \"dct_coef\"\n  )\n  \n  attr(out, \"order\") <- order\n  out\n}\n\n# convenience function\ndct_coef <- function(x = double(), order = NULL){\n  args <- names(call_match())\n  if (!\"order\" %in% args) {\n    order <- vec_size(x)\n  }\n  x <- vec_cast(x, double())\n  order <- vec_cast(order, integer())\n  \n  new_dct_coef(x, order)\n  \n}\n```\n:::\n\n\nIn order to get a nice looking printout of the vector, we need to define a `format` method.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nformat.dct_coef <- function(x, ...){\n  formatC(field(x, \"x\"))\n}\n\nobj_print_footer.dct_coef <- function(x){\n  cat(\"order:\", attr(x, \"order\"), \"\\n\", sep = \" \")\n}\n```\n:::\n\n\nLet's see it in action\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# empty\ndct_coef()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<dct_coef[0]>\norder: 0 \n```\n\n\n:::\n\n```{.r .cell-code}\n# made up\ndct_coef(1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<dct_coef[10]>\n [1] 1  2  3  4  5  6  7  8  9  10\norder: 10 \n```\n\n\n:::\n\n```{.r .cell-code}\n# actual\ncoef1 <- dct_coef(dcts[[1]])\ncoef1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<dct_coef[5]>\n[1] 495.3  -21.89 57.28  8.105  -5.456\norder: 5 \n```\n\n\n:::\n:::\n\n\n## Casting and coersion\n\nNow, we need to provide some casting and coersion methods.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# self casting\nvec_ptype2.dct_coef.dct_coef <- function(x, y, ...) dct_coef()\nvec_cast.dct_coef.dct_coef <- function(x, to, ...) x\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# casting with doubles\nvec_ptype2.double.dct_coef <- function(x, y, ...) double()\nvec_ptype2.dct_coef.double <- function(x, y, ...) double()\n\nvec_cast.dct_coef.double <- function(x, to, ...) dct_coef(x)\nvec_cast.double.dct_coef <- function(x, to, ...) vec_data(x)$x\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_c(2.1, coef1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]   2.100000 495.277326 -21.891001  57.284753   8.105410  -5.455812\n```\n\n\n:::\n:::\n\n\n## Special Slicing\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_restore.dct_coef <- function(x, to, ..., i = NULL){\n  if (vec_size(x) < 1) {\n    return(new_dct_coef(order = 0L))\n  }\n  \n  in_data <- field(x, \"x\")\n  in_param <- field(x, \"param\")\n  in_order <- max(in_param)\n  \n  full_param <- 1:in_order\n  missing_param <- full_param[-in_param]\n  out_param <- c(in_param, missing_param)\n  \n  zero_pad <- rep(0, vec_size(missing_param))\n  out_data <- c(in_data, zero_pad)[order(out_param)]\n  \n  new_dct_coef(out_data, order = in_order)\n  \n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoef1[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<dct_coef[1]>\n[1] 495.3\norder: 1 \n```\n\n\n:::\n\n```{.r .cell-code}\ncoef1[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<dct_coef[3]>\n[1] 495.3  -21.89 57.28 \norder: 3 \n```\n\n\n:::\n\n```{.r .cell-code}\ncoef1[4:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<dct_coef[5]>\n[1] 0      0      0      8.105  -5.456\norder: 5 \n```\n\n\n:::\n\n```{.r .cell-code}\ncoef1[-1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<dct_coef[5]>\n[1] 0      -21.89 57.28  8.105  -5.456\norder: 5 \n```\n\n\n:::\n:::\n\n\n## Some extra methods\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot.dct_coef <- function(x, ..., n = attr(x, \"order\")){\n  y <- idct(field(x, \"x\"), n = n)\n  x <- seq_along(y)\n  \n  plot(x, y, ...)\n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(coef1, n = 40, type = 'l', col = \"red\")\n```\n\n::: {.cell-output-display}\n![](2025-07-04_vctrs_files/figure-html/unnamed-chunk-12-1.png){width=768}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_arith.dct_coef <- function(op, x, y, ...) {\n  UseMethod(\"vec_arith.dct_coef\", y)\n}\n\nvec_arith.dct_coef.dct_coef <- function(op, x, y, ...){\n  new_size <- min(c(vec_size(x), vec_size(y)))\n  if (new_size < 1 ) {\n    return(new_dct_coef(order = 0L))\n  }\n  x_dat <- field(x, \"x\")[1:new_size]\n  y_dat <- field(y, \"x\")[1:new_size]\n  \n  switch(\n    op,\n    \"+\" = new_dct_coef(vec_arith_base(op, x_dat, y_dat), order = new_size),\n    \"-\" = new_dct_coef(vec_arith_base(op, x_dat, y_dat), order = new_size),\n    \"*\" = new_dct_coef(vec_arith_base(op, x_dat, y_dat), order = new_size),\n    \"/\" = new_dct_coef(vec_arith_base(op, x_dat, y_dat), order = new_size)\n  )\n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(coef1 * coef1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<dct_coef[5]>\n[1] 2.453e+05 479.2     3282      65.7      29.77    \norder: 5 \n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\njawn <- map_dbl(\n  1:10000,\n  ~(sum(sample(1:8, 3, replace = T))+4) + (sum(sample(1:8, 4, replace = T))+4)\n)\n\nmedian(jawn)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 39\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(90-4)/(5.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15.63636\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(10 * 5.5) + (10 * 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 95\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.5\n```\n\n\n:::\n:::\n\n",
    "supporting": [
      "2025-07-04_vctrs_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}