{
  "hash": "de5c02a7b0267201c508e4f1fbccd023",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"tidytuesday color survey\"\ndate: 2025-07-09\nformat: html\neditor: visual\ncode-fold: true\nknitr: \n  opts_chunk: \n    message: false\n    warning: false\n---\n\nWhen I saw that the TidyTuesday dataset was the [the XKCD color survey this week](https://github.com/rfordatascience/tidytuesday/blob/main/data/2025/2025-07-08/readme.md), I had to jump in!\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nsource(here::here(\"_defaults.R\"))\nlibrary(tidyverse)\nlibrary(tidytuesdayR)\nlibrary(tinytable)\nlibrary(mgcv)\nlibrary(marginaleffects)\nlibrary(ggdist)\nlibrary(ggdensity)\nlibrary(geomtextpath)\nset.seed(2025-07-08)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# eval: false\n# downloading & saving to avoid \n# downloading on every quarto render\ntuesdata <- tidytuesdayR::tt_load('2025-07-08')\n\nfs::dir_create(\"data\")\nwrite_rds(tuesdata, \"data/tuesdata.rds\")\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntuesdata <- read_rds(\"data/tuesdata.rds\")\n\nanswers <- tuesdata$answers\ncolor_ranks <- tuesdata$color_ranks\nusers <- tuesdata$users\n```\n:::\n\n\nI first started digging into the `answers` dataframe.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nsummary(answers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    user_id           hex                 rank      \n Min.   :     1   Length:1058211     Min.   :1.000  \n 1st Qu.: 39387   Class :character   1st Qu.:2.000  \n Median : 77661   Mode  :character   Median :2.000  \n Mean   : 77261                      Mean   :2.499  \n 3rd Qu.:115068                      3rd Qu.:3.000  \n Max.   :152401                      Max.   :5.000  \n```\n\n\n:::\n:::\n\n\nThe `rank` column is a unique ID for color labels, which means these are all of the responses for the top 5 provided color labels.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ncolor_ranks |> \n  slice_head(n = 5) ->\n  top5\n\ntop5 |> \n  tt() |> \n  style_tt(\n    i = 1:5,\n    j = 3,\n    background = top5$hex\n  )\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<!-- preamble start -->\n\n    <script>\n\n      function styleCell_qddclpfsp962e4ctu769(i, j, css_id) {\n          var table = document.getElementById(\"tinytable_qddclpfsp962e4ctu769\");\n          var cell = table.querySelector(`[data-row=\"${i}\"][data-col=\"${j}\"]`);\n          if (cell) {\n              console.log(`Styling cell at (${i}, ${j}) with class ${css_id}`);\n              cell.classList.add(css_id);\n          } else {\n              console.warn(`Cell at (${i}, ${j}) not found.`);\n          }\n      }\n      function insertSpanRow(i, colspan, content) {\n        var table = document.getElementById('tinytable_qddclpfsp962e4ctu769');\n        // Find the row with data-row attribute matching i\n        var targetRow = table.querySelector(`tr [data-row=\"${i}\"]`).closest('tr');\n        var newRow = table.insertRow(targetRow.rowIndex);\n        var newCell = newRow.insertCell(0);\n        newCell.setAttribute(\"colspan\", colspan);\n        newCell.setAttribute(\"data-col\", \"0\");\n        newCell.setAttribute(\"data-row\", i - 1);\n        // newCell.innerText = content;\n        // this may be unsafe, but innerText does not interpret <br>\n        newCell.innerHTML = content;\n      }\n      function spanCell_qddclpfsp962e4ctu769(i, j, rowspan, colspan) {\n        var table = document.getElementById(\"tinytable_qddclpfsp962e4ctu769\");\n        const targetCell = table.querySelector(`[data-row=\"${i}\"][data-col=\"${j}\"]`);\n        if (!targetCell) {\n          console.warn(`Cell at (${i}, ${j}) not found.`);\n        }\n\n        // Get all cells that need to be removed\n        const cellsToRemove = [];\n        for (let r = 0; r < rowspan; r++) {\n          for (let c = 0; c < colspan; c++) {\n            if (r === 0 && c === 0) continue; // Skip the target cell\n            const cell = table.querySelector(`[data-row=\"${i + r}\"][data-col=\"${j + c}\"]`);\n            if (cell) {\n              cellsToRemove.push(cell);\n            }\n          }\n        }\n\n        // Remove all cells\n        cellsToRemove.forEach(cell => cell.remove());\n\n        // Set rowspan and colspan of the target cell if it exists\n        if (targetCell) {\n          targetCell.rowSpan = rowspan;\n          targetCell.colSpan = colspan;\n        }\n      }\n      // tinytable span after\n      window.addEventListener('load', function () {\n          var cellsToStyle = [\n            // tinytable style arrays after\n          { positions: [ { i: '5', j: 2 },  ], css_id: 'tinytable_css_c7ivnuqya9awqnpcwdh8',}, \n          { positions: [ { i: '4', j: 2 },  ], css_id: 'tinytable_css_oeybl8osjdzldkdkv7sh',}, \n          { positions: [ { i: '3', j: 2 },  ], css_id: 'tinytable_css_w0fhrbqzh60syvadizjs',}, \n          { positions: [ { i: '2', j: 2 },  ], css_id: 'tinytable_css_irxb23khg1gqa4l32nch',}, \n          { positions: [ { i: '1', j: 2 },  ], css_id: 'tinytable_css_bv7nqo7q741x66v3b37l',}, \n          { positions: [ { i: '5', j: 0 }, { i: '5', j: 1 },  ], css_id: 'tinytable_css_l7hfrwsj0zswc59sv3m2',}, \n          { positions: [ { i: '0', j: 0 }, { i: '0', j: 1 }, { i: '0', j: 2 },  ], css_id: 'tinytable_css_lbdfk4e5amo63e11ckcs',}, \n          ];\n\n          // Loop over the arrays to style the cells\n          cellsToStyle.forEach(function (group) {\n              group.positions.forEach(function (cell) {\n                  styleCell_qddclpfsp962e4ctu769(cell.i, cell.j, group.css_id);\n              });\n          });\n      });\n    </script>\n\n    <style>\n      /* tinytable css entries after */\n      .table td.tinytable_css_c7ivnuqya9awqnpcwdh8, .table th.tinytable_css_c7ivnuqya9awqnpcwdh8 { background-color: #653700; border-bottom: solid #d3d8dc 0.1em; }\n      .table td.tinytable_css_oeybl8osjdzldkdkv7sh, .table th.tinytable_css_oeybl8osjdzldkdkv7sh { background-color: #ff81c0; }\n      .table td.tinytable_css_w0fhrbqzh60syvadizjs, .table th.tinytable_css_w0fhrbqzh60syvadizjs { background-color: #0343df; }\n      .table td.tinytable_css_irxb23khg1gqa4l32nch, .table th.tinytable_css_irxb23khg1gqa4l32nch { background-color: #15b01a; }\n      .table td.tinytable_css_bv7nqo7q741x66v3b37l, .table th.tinytable_css_bv7nqo7q741x66v3b37l { background-color: #7e1e9c; }\n      .table td.tinytable_css_l7hfrwsj0zswc59sv3m2, .table th.tinytable_css_l7hfrwsj0zswc59sv3m2 { border-bottom: solid #d3d8dc 0.1em; }\n      .table td.tinytable_css_lbdfk4e5amo63e11ckcs, .table th.tinytable_css_lbdfk4e5amo63e11ckcs { border-top: solid #d3d8dc 0.1em; border-bottom: solid #d3d8dc 0.05em; }\n    </style>\n    <div class=\"container\">\n      <table class=\"table table-borderless\" id=\"tinytable_qddclpfsp962e4ctu769\" style=\"width: auto; margin-left: auto; margin-right: auto;\" data-quarto-disable-processing='true'>\n        <thead>\n        \n              <tr>\n                <th scope=\"col\" data-row=\"0\" data-col=\"0\">color</th>\n                <th scope=\"col\" data-row=\"0\" data-col=\"1\">rank</th>\n                <th scope=\"col\" data-row=\"0\" data-col=\"2\">hex</th>\n              </tr>\n        </thead>\n        \n        <tbody>\n                <tr>\n                  <td data-row=\"1\" data-col=\"0\">purple</td>\n                  <td data-row=\"1\" data-col=\"1\">1</td>\n                  <td data-row=\"1\" data-col=\"2\">#7e1e9c</td>\n                </tr>\n                <tr>\n                  <td data-row=\"2\" data-col=\"0\">green</td>\n                  <td data-row=\"2\" data-col=\"1\">2</td>\n                  <td data-row=\"2\" data-col=\"2\">#15b01a</td>\n                </tr>\n                <tr>\n                  <td data-row=\"3\" data-col=\"0\">blue</td>\n                  <td data-row=\"3\" data-col=\"1\">3</td>\n                  <td data-row=\"3\" data-col=\"2\">#0343df</td>\n                </tr>\n                <tr>\n                  <td data-row=\"4\" data-col=\"0\">pink</td>\n                  <td data-row=\"4\" data-col=\"1\">4</td>\n                  <td data-row=\"4\" data-col=\"2\">#ff81c0</td>\n                </tr>\n                <tr>\n                  <td data-row=\"5\" data-col=\"0\">brown</td>\n                  <td data-row=\"5\" data-col=\"1\">5</td>\n                  <td data-row=\"5\" data-col=\"2\">#653700</td>\n                </tr>\n        </tbody>\n      </table>\n    </div>\n<!-- hack to avoid NA insertion in last line -->\n```\n\n:::\n:::\n\n\n## Colorspaces\n\nTo make some plots, I'll use functions from `{colorspace}` to convert the hex codes to HLS (hue, lightness, saturation) values.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(colorspace)\n```\n:::\n\n\n-   H: A value in degrees from 0 to 360.\n\n    -   0/360 ≈ red\n\n    -   90 ≈ yellow to green\n\n    -   180 ≈ green to blue\n\n    -   270 ≈ blue to purple\n\n-   lightness: A value ranging from 0 to 1\n\n-   saturation: A value ranging from 0 to 1\n\nColors become somewhat indistinct at both very high and very low Lightness\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# an example color space grid\n# with a fixed saturation\nexpand_grid(\n  H = 0:360,\n  L = seq(0, 1, length = 50)\n) |> \n  rowwise() |> \n  mutate(\n    hls = HLS(H, L, 0.75) |> list(),\n    hex = hex(hls)\n  ) |> \n  ungroup() ->\n  hl_demo\n```\n:::\n\n\n\n::: {.cell renderings='[\"light\",\"dark\"]' crop='true'}\n\n```{.r .cell-code  code-fold=\"true\"}\nhl_demo |> \n  ggplot(\n    aes(H, L)\n  ) +\n    geom_tile(\n      aes(fill = hex)\n    ) +\n    scale_x_continuous(expand = expansion(0)) + \n    scale_y_continuous(expand = expansion(0)) +\n    scale_fill_identity() ->\n    hl_rect_plot\n\n# I'm using the new quarto renderings option\nhl_rect_plot\nhl_rect_plot + theme_dark()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=768}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-2.png){width=768}\n:::\n:::\n\n\nThe indistinctness at the top and bottom is why the colorspace is often visualized as a colorwheel.\n\n\n::: {.cell renderings='[\"light\",\"dark\"]' crop='true'}\n\n```{.r .cell-code}\nhl_demo |> \n  ggplot(\n    aes(H, L)\n  ) +\n  geom_tile(\n    aes(\n      fill = hex, \n      color = hex\n    )\n  ) +\n  scale_x_continuous(\n    breaks = c(0, 90, 180, 270),\n    expand = expansion(0)\n  ) +\n  scale_y_continuous(\n    expand = expansion(0)\n  ) +\n  scale_fill_identity() +\n  scale_color_identity() +\n  coord_radial()->\n  color_wheel\n\ncolor_wheel\ncolor_wheel + theme_dark()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=480}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-2.png){width=480}\n:::\n:::\n\n\nBut it's probably best thought of as a color sphere with a darker and a lighter hemisphere\n\n\n::: {.cell renderings='[\"light\",\"dark\"]' crop='true'}\n\n```{.r .cell-code}\nhl_demo |> \n  mutate(\n    eq_dist = 1 - abs(L - 0.5),\n    hemisphere = case_when(\n      L > 0.5 ~ \"lighter\",\n      .default = \"darker\"\n    ),\n    H2 = case_when(\n      hemisphere == \"lighter\" ~ abs(H - 360),\n      .default = H\n    )\n  ) |> \n  ggplot(\n    aes(H2, eq_dist)\n  ) +\n  geom_tile(\n    aes(\n      fill = hex, \n      color = hex\n    )\n  ) +\n  scale_x_continuous(\n    breaks = c(0, 90, 180, 270),\n    expand = expansion(0)\n  ) +\n  scale_y_continuous(\n    expand = expansion(0)\n  ) +\n  scale_fill_identity() +\n  scale_color_identity() +\n  facet_wrap(~hemisphere, labeller = label_both) +\n  coord_radial() +\n  theme_no_y() +\n  theme_no_x() ->\n  color_sphere\n\ncolor_sphere\ncolor_sphere + theme_dark()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=768}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-2.png){width=768}\n:::\n:::\n\n\n## Looking at blue\n\nI'll convert all of the answers hex codes to HLS for plotting.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nanswers |> \n  pull(hex) |> \n  hex2RGB() |> \n  as(\"HLS\") ->\n  answers_hsl_obj\n\n# the colorspace objects are S4 classes, so...\nanswers_hsl_obj@coords |> \n  as_tibble() ->\n  ans_hsl_cols\n\nanswers |> \n  bind_cols(ans_hsl_cols) |> \n  left_join(\n    color_ranks |> select(rank, color)\n  ) ->\n  answers_hsl\n```\n:::\n\n\nWe can plot a subset of blue to see how it looks:\n\n\n::: {.cell crop='true' renderings='[\"light\",\"dark\"]'}\n\n```{.r .cell-code}\nanswers_hsl |> \n  filter(color == \"blue\") |> \n  # thin to deal with overplotting\n  slice_sample(n = 500) |> \n  # slice up by saturation\n  mutate(\n    saturation = case_when(\n      S <= (1/3) ~ \"low\",\n      S <= (2/3) ~ \"med\",\n      S <= 1 ~ \"high\"\n    ) |> \n      fct_reorder(S)\n  ) |> \n  ggplot(\n    aes(H, L)\n  ) +\n  geom_point(\n    aes(\n      color = hex\n    )\n  ) +\n  scale_x_continuous(\n    limits = c(0, 360),\n    breaks = c(0, 90, 180, 270),\n    expand = expansion(0)\n  ) +\n  scale_y_continuous(\n    expand = expansion(0),\n    limits = c(0, 1)\n  ) +\n  scale_color_identity() +\n  coord_radial() +\n  facet_wrap(\n    ~saturation, \n    labeller = label_both\n  ) ->\n  blues_plot\n\n\nblues_plot\nblues_plot + theme_dark()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=1152}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-2.png){width=1152}\n:::\n:::\n\n\n## Blue vs green\n\nThere was a \"[find your boundary between green and blue](https://ismy.blue/)\" quiz that went a little viral recently, and we could probably recreate it here.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# get all green & blue answers\nanswers_hsl |> \n  filter(color %in% c(\"green\", \"blue\")) |> \n  mutate(is_blue = color == \"blue\") ->\n  gb_hsl\n\n# subsample to not overwhelm my computer\ngb_hsl |> \n  slice_sample(prop = 0.1) -> \n  gb_hsl_subset\n```\n:::\n\n\nIf I was doing this for real for real, I'd fit a big bad Bayesian model, but I'll go for a simpler gam here.\nBut what I *will* do (because I've never had cause to do it before!) is fit a \"splines on a sphere\" smooth!\nI'll need to prepare the data by converting the `H` and `L` columns into degrees in radians.\n\nHere I'll be honest and say I'm not 100% sure how the lightness dimension works.\nI'm guessing that it's actually describing the distance along the center axis of the sphere, and I had to make some notes about how that'd translate into an angle across the surface of the sphere.\n\n![](images/angles.jpeg){fig-align=\"center\"}\n\nConverting the `H` scale to radians is easier, but looking at the help page for `smooth.construct.sos.smooth.spec()`, it looks like I'll need to convert it into east and west hemispheres.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nhl_demo |> \n  select(-hls) |> \n  mutate(\n    L_rad = asin((L - 0.5)/0.5),\n    H_rad = (H * (pi/180)) - pi\n  ) ->\n  hl_demo_rad\n```\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## Hemispheres again\n\nI just want to see how the conversion to radians affects the color sphere plot I did before.\n\n\n::: {.cell renderings='[\"light\",\"dark\"]' crop='true'}\n\n```{.r .cell-code}\nhl_demo_rad |>\n  slice(.by = hex, 1) |> \n  mutate(\n    hemi = case_when(\n      L_rad > 0 ~ \"lighter\",\n      .default = \"darker\"\n    ),\n    dist = abs(L_rad),\n    H2 = case_when(\n      hemi == \"lighter\" ~ abs(H  - 360),\n      .default = H\n    )\n  ) |>\n  ggplot(\n    aes(H2, dist)\n  ) +\n  geom_point(\n    aes(color = hex)\n  ) +\n  scale_color_identity()+\n  scale_y_reverse(\n    expand = expansion(0)\n  ) +\n  scale_x_continuous(\n    expand = expansion(0),\n    limits = c(0, 360),\n    breaks = c(0, 90, 180, 270)\n  ) +\n  facet_wrap(~hemi) +\n  coord_polar() +\n  theme_no_y() +\n  theme_no_x() ->\n  hl_sphere2\n\nhl_sphere2\nhl_sphere2 + theme_dark()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=768}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-2.png){width=768}\n:::\n:::\n\n:::\n\nOk!\nTime for splines on the sphere!\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ngb_hsl_subset |> \n  mutate(\n    H_rad = (H * (pi/180)) - pi,\n    L_rad = asin((L - 0.5)/0.5)\n  ) ->\n  gb_hsl_subset\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# eval: false\n# this took a while to fit\ngb_mod <- bam(\n  is_blue ~ s(L_rad, H_rad, bs = \"sos\"),\n  family = binomial,\n  data = gb_hsl_subset\n)\n\nwrite_rds(gb_mod, \"gb_mod.rds\")\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ngb_mod <- read_rds(\"gb_mod.rds\")\n```\n:::\n\n\nJust as a first glance:\n\n\n::: {.cell crop='true'}\n\n```{.r .cell-code  code-fold=\"false\"}\nplot(gb_mod)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){width=60%}\n:::\n:::\n\n\nThis is *pretty cool!*\n\n## Plotting the boundaries\n\nFor plotting the boundaries, I'm going to make a dense grid in the polar coordinate space and then convert that to radians.\nI'll use the \"sphere\" grid to get predictions from the model.\nThis is, admittedly, a *lot* of math just to get the figure just like I want it.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"A lot of π\"}\n# this creates a single hemisphere\nexpand_grid(\n  x = seq(-pi/2, pi/2, length = 100),\n  y = seq(-pi/2, pi/2, length = 100),\n) |>\n  mutate(\n    dist =  sqrt((x^2) + (y^2))\n  ) |> \n  filter(\n   dist < (pi/2)\n  ) |> \n  mutate(\n    L_rad = (pi/2)-dist,\n    H_rad = atan2(x,y),\n    H_rad = case_when(\n      H_rad < 0 ~ H_rad + (2*pi),\n      .default = H_rad\n    ),\n    H_rad = H_rad - pi\n  ) ->\n  hemi_1\n\n# creating the second hemisphere\nhemi_1 |> \n  mutate(\n    L_rad = -L_rad\n  )->\n  hemi_2\n\n\nbind_rows(\n  hemi_1, \n  hemi_2\n) ->\n  sphere\n\n# finalizing the predictions grid\nsphere |> \n  mutate(\n    H = (H_rad + pi) / (pi/180),\n    L = (sin(L_rad)/2) + 0.5,\n    hemi = case_when(\n      L_rad < 0 ~ \"darker\",\n      .default = \"lighter\"\n    )\n  )  |> \n  rowwise() |> \n  mutate(\n    hls = HLS(H, L, 0.75) |> list(),\n    hex = hex(hls)\n  ) |> \n  select(-hls) |> \n  ungroup() ->\n  sphere_pred\n```\n:::\n\n\nGrabbing the predictions\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# eval: false\n# this took a while to run\ngb_mod |> \n  predictions(\n    newdata = sphere_pred\n  ) ->\n  gb_pred\n\nwrite_rds(gb_pred, \"gb_pred.rds\")\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ngb_pred <- read_rds(\"gb_pred.rds\")\n```\n:::\n\n\nAnd plotting\n\n\n::: {.cell renderings='[\"light\",\"dark\"]' crop='true'}\n\n```{.r .cell-code}\ngb_pred |> \n  mutate(\n    x = case_when(\n      hemi == \"lighter\" ~ -x,\n      .default = x\n    )\n  ) |> \n  ggplot(\n    aes(x, y)\n  ) + \n  geom_raster(\n    aes(fill = hex)\n  ) +\n  geom_textcontour(\n    aes(z = estimate, color = hemi),\n    breaks = c(0.2, 0.5, 0.8),\n    hjust = 0.2\n  ) +\n  scale_fill_identity() +\n  scale_color_manual(\n    values = c(\"white\", \"black\")\n  ) +\n  guides(color = \"none\") +\n  facet_wrap(~hemi)+\n  coord_fixed()+\n  theme_no_x() + \n  theme_no_y()->\n  pred_plot\n\npred_plot\npred_plot + theme_dark()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-23-1.png){width=960}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-23-2.png){width=960}\n:::\n:::\n\n\nIt looks like on the darker side of the sphere, green has an \"advantage\" where more colors rotated towards blue, relative to the equator, are classified as \"green\", but on the lighter side of the sphere, it goes the other way.\n\nI'd also started messing around with how labeling a color \"light X\" vs \"dark X\" shifts its location across the sphere, but I think this was enough for one post.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}