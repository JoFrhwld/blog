{
  "hash": "b1aad56435d0d6ca49e0772f215169f3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Getting the xkcd color survey sqlite database\"\ndate: 2025-07-16\nformat: html\neditor: visual\ndraft: false\n---\n\nI had a lot of fun working with the XKCD [color](https://jofrhwld.github.io/blog/posts/2025/07/2025-07-09_color-survey/) [survey](https://jofrhwld.github.io/blog/posts/2025/07/2025-07-12_color-sphere/) [data](https://jofrhwld.github.io/blog/posts/2025/07/2025-07-14_light-color/), and I think I'll keep messing around with it here and there in the future.\nBut I also think I'll want access to the full data.\nThe tidytuesday data set was necessarily boiled down.\nThe `answers` data frame contained just one hex code associated with one color label, not every color label given to every hex code in the survey.\nThe full data set is available as a sqlite dump linked to from [the xkcd blog](https://blog.xkcd.com/2010/05/03/color-survey-results/), so this post is just about how I set up access to it within my blog RStudio project.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# basic setup\nsource(here::here(\"_defaults.R\"))\nlibrary(tidyverse)\nlibrary(colorspace)\n```\n:::\n\n\n## Necessary Libraries\n\nFor this workflow, I used\n\n-   `{fs}`: for working with file systems\n\n-   `{DBI}` and `{RSQLite}`: for working with the sqlite database\n\n-   `{dbplyr}`: for using dplyr commands on the database.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(fs)\nlibrary(DBI)\nlibrary(RSQLite)\nlibrary(dbplyr)\n```\n:::\n\n\n## Downloading the database\n\nIf you want to hang onto the tar file locally (in case of linkrot), you could download it to a real location, but I just want to send it to a temp file.\nYou can get the temp directory for your R session with `fs::path_temp()`, and I created the destination file using `fs::path()`.\n\n``` r\ndownload.file(\n  \"http://xkcd.com/color/colorsurvey.tar.gz\",\n  fs::path(\n    fs::path_temp(),\n    \"colorsurvey.tar.gz\"\n  )\n)\n```\n\nThen, it's a matter of untaring it.\n\n``` r\nuntar(\n  fs::path(fs::path_temp(), \"colorsurvey.tar.gz\"),\n  exdir = fs::path(fs::path_temp(), \"colorsurvey\")\n)\n```\n\nYou can get a list of the available files like so:\n\n``` r\npath(\n  path_temp(),\n  \"colorsurvey\"\n) |>\n  dir_ls() ->\n  dump_files\n```\n\nI'm not actually including this code in executable chunks to avoid downloading the tar file on every re-render, but `dump_files` will look something like\n\n```         \n[1] /var/folders/xyz/mainsurvey_sqldump.txt\n[2] /var/folders/xyz/satfaces_sqldump.txt\n```\n\nIt's the `mainsurvey_sqldump.txt` file that we want to process.\n\n``` r\ndump_files |>\n  keep(\n    ~str_detect(.x, \"mainsurvey\")\n  ) ->\n  survey_dump\n```\n\n## Creating the local database\n\nTo set up the database, we need to read the sqldump file.\nApparently there's a sqlite command `.read` that will do this, but I couldn't figure out how to run it within a `{DBI}` or `{RSQLite}` function, so I have to use a `system()` command.\n\nFirst, I have decide where this database is going, and since I don't want it to wind up being duplicated in every post directory, I'll create a top level project directory called `data`.\n\n``` r\nfs::dir_create(\n  here::here(\"data\")\n)\n```\n\nThen, I need to decide on the name of the database file.\n\n``` r\nlocal_sql_path <- here::here(\"data\", \"colors.sqlite\")\n```\n\nI'll glue my variables into the system command I want:\n\n``` r\ncreation_command <- str_glue(\n  \"sqlite3 {local_sql_path} < {survey_dump}\"\n)\n```\n\nAnd then finally run it.\n\n``` r\nsystem(creation_command)\n```\n\n### Updating `.gitignore`\n\nYou'll probably want to add `*.sqlite` file to your gitignore, which you can either do do by hand or with `usethis::use_git_ignore()`\n\n``` r\nusethis::use_git_ignore(\"*.sqlite\")\n```\n\n## Looking at the database\n\nNow we can connect to the database and look at it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolordb <- dbConnect(\n  RSQLite::SQLite(), \n  here::here(\"data\", \"colors.sqlite\")\n)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbListTables(colordb)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"answers\" \"names\"   \"users\"  \n```\n\n\n:::\n:::\n\n\nWe can access tables from the database like it's a dataframe with `tbl()`.\nIt doesn't actually read the whole thing into memory.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolors <- tbl(colordb, \"answers\")\ncolors\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   table<`answers`> [?? x 7]\n# Database: sqlite 3.50.1 [/Users/joseffruehwald/Documents/blog/data/colors.sqlite]\n      id user_id  datestamp     r     g     b colorname   \n   <int>   <int>      <dbl> <int> <int> <int> <chr>       \n 1     1       1 1267418734    72   100   175 pastel blue \n 2     2       1 1267418739   204   177   246 faint violet\n 3     3       1 1267418769   182   226   245 baby blue   \n 4     4       1 1267418773   130    64   234 purple      \n 5     5       2 1267419006    75    49   234 blue        \n 6     6       2 1267419010    76   215   249 light blue  \n 7     7       2 1267419015   111   145   122 olive green \n 8     8       2 1267419019    88    70     1 brown       \n 9     9       2 1267419021   218    35   156 pink        \n10    10       4 1267419023   154    42   159 purple      \n# ‚Ñπ more rows\n```\n\n\n:::\n:::\n\n\nNow, we can run the `{dplyr}`-like commands on this table thanks to `{dbplyr}` and only load the rows we're interested in.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolors |> \n  # get just blue and light blue\n  filter(\n    colorname %in% c(\"blue\", \"light blue\")\n  ) |> \n  # manually get some hex values\n  mutate(\n    rh = sql(\"printf('%02X', r)\"),\n    gh = sql(\"printf('%02X', g)\"),\n    bh = sql(\"printf('%02X', b)\")\n  ) |> \n  mutate(\n    hex = sql(\"rh||gh||bh\")\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 11]\n# Database: sqlite 3.50.1 [/Users/joseffruehwald/Documents/blog/data/colors.sqlite]\n      id user_id  datestamp     r     g     b colorname rh    gh    bh    hex   \n   <int>   <int>      <dbl> <int> <int> <int> <chr>     <chr> <chr> <chr> <chr> \n 1     5       2 1267419006    75    49   234 blue      4B    31    EA    4B31EA\n 2    17       2 1267419032    41   201   234 blue      29    C9    EA    29C9EA\n 3    22       2 1267419040    73    97   236 blue      49    61    EC    4961EC\n 4    27       4 1267419062    33   115   229 blue      21    73    E5    2173E5\n 5    45       6 1267419091    14    47   164 blue      0E    2F    A4    0E2FA4\n 6    49       4 1267419096    64   128   225 blue      40    80    E1    4080E1\n 7    57       7 1267419102    74    89   253 blue      4A    59    FD    4A59FD\n 8    87       6 1267419139   120   158   209 blue      78    9E    D1    789ED1\n 9   100       7 1267419170    74   107   231 blue      4A    6B    E7    4A6BE7\n10   115      10 1267419193    95   196   210 blue      5F    C4    D2    5FC4D2\n# ‚Ñπ more rows\n```\n\n\n:::\n:::\n\n\nI'm kind of glad I messed around with manually converting the rgb values to hex values, cause it turns out I don't know what the right way is to convert these rgb values to hex codes.\nMy manual approach gives me [#4B31EA]{style=\"background: #4B31EA; color: white;\"} for the first row, but using the `{colorspace}` package, I get two different hex codes depending on whether I assume `r`, `g`, `b` are RGB or sRGB values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRGB(\n  75/255,\n  49/255,\n  234/255\n) |> \n  hex() \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"#9479F6\"\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsRGB(\n  75/255,\n  49/255,\n  234/255\n) |> \n  hex()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"#4B31EA\"\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nswatchplot(\n  \"RGB\" = \"#9479F6\",\n  \"sRGB\" = \"#4B31EA\"\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=768}\n:::\n:::\n\n\nü§∑‚Äç‚ôÇÔ∏è\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbDisconnect(colordb)\n```\n:::\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}