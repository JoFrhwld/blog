{
  "hash": "15ee71d1c4d4d9cd07ef47685261c380",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Setting Up Rogue Scholar\ndraft: false\nengine: knitr\n---\n\nI'm not sure when I first came across his stuff, but I've really admired Andrew Heiss' public scholarship, [including his blog](https://www.andrewheiss.com/blog/), which is full of handy stuff.\nAt some point I noticed he had post-level DOIs minted.\nI knew you could mint repository-level DOIs with GitHub and Zenodo, but maintaining each post as a repository and adding them as submodules to a blog is...\na lot.\n\nTurns out, [Rogue Scholar](https://rogue-scholar.org/) is a science blogging platform that will archive your posts and mint a DOI for them!\nAs I learned from reading (and in communicating with the Rogue Scholar Team), the requirements are\n\n-   The blog needs to be licensed CC-BY\n\n-   Every post needs an author\n\n-   Every post needs a date\n\n-   The full post needs to be published in the RSS feed\n\nAdditionally, it's possible to pre-assign your post a DOI using the `commonmeta` tool.\nSo, this post is in part a description about how I spruced up my quarto infrastructure to enforce some of these requirements, and is also partially a test to make sure I did it right!\n\n## Enforcing metadata\n\nI sometimes have a bad habit of creating a new quarto file for a post, and forgetting to add a date, which would be no good for the RSS feed.\nAnd if I had to go back and forth between [the Rogue Scholar archive](https://rogue-scholar.org/communities/jofrhwld/) and my blog files to error-free copy-paste DOIs, this was never going to work.\nMy approach was to put together a quarto pre-render script, [which you can look at in full here](/defaults.html#prerender).\n\nThe upshot is that I use `pathlib` to walk through and find all of my post-level directories, which I have (maybe annoyingly) organized like so:\n\n```         \nblog/\n└── posts/\n    └── YYYY/\n        └── MM/\n            └── YYYY-MM-DD_slug/\n                └── index.qmd\n```\n\nI can take the `YYYY-MM-DD` portion of the post directory to get the date, and I can generate a DOI using [commonmeta-py](https://python.commonmeta.org/) like so\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom commonmeta import encode_doi\nencode_doi(\n  \"10.59350\" #the Rogue Scholar prefix\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'https://doi.org/10.59350/fdgm0-evb66'\n```\n\n\n:::\n:::\n\n\nThen, I drop this info into a post-level `_metadata.yml` file.\nIf you look at the actual function I wrote to update `_metadata.yml`, I have a lot of conditionals because\n\n1.  If `_metadata.yml` *already* has a `doi` field, I *don't* want to overwrite it!\n2.  And if `_metadata.yml` already has an accurate date, I don't want waste the time on writing to it either.\n\nA nice thing about how I set this up, though, is if I create a post directory and don't wind up publishing the post until a few days later, the date metadata ought to get automatically updated if I just change the post's directory name.\n\nWith my pre-render script written, I just added it to the `pre-render` list in my quarto configuration file.\n\n## Adjusting my GitHub action\n\nFor the most part, my GitHub publication action isn't running code chunks because I'm [freezing execution locally](https://quarto.org/docs/projects/code-execution.html#freeze).\nBut the pre-render script runs every time, and needs to point to the right python environment that has `commonmeta-py` and `pyyaml` installed.\nI'm using `{renv}` to manage all of my dependencies, so getting this to work involved adding the following step before Quarto publish:\n\n``` yaml\n- name: Set Quarto Python\n  run: |\n    echo \"QUARTO_PYTHON=renv/python/virtualenvs/renv-python-3.12/bin/python\" >> $GITHUB_ENV\n```\n\n## Wrapping up\n\nHopefully I configured this all correctly!\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}