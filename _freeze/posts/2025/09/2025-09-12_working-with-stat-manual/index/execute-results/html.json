{
  "hash": "c99cab238f25a0175bcc9de7f0fd18d4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Working with stat_manual()\nimage: index_files/figure-html/unnamed-chunk-13-1.png\n---\n\nFollowing on from [my post about darkmode in ggplot2 4.0](../2025-09-11_ggplot-4-0-and-dark-mode/), I wanted to also mess around with the new `stat_manual()` that's available.\nAnd folks, it's good!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(here::here(\"_defaults.R\"))\nlibrary(tidyverse)\nlibrary(tidynorm)\nlibrary(scales)\n```\n:::\n\n\n[The announcement blog post](https://www.tidyverse.org/blog/2025/09/ggplot2-4-0-0/#manual) says\n\n> You can provide \\[stat_manual()\\] any function that both ingests and returns a data frame.\n> It can create new aesthetics or modify pre-existing aesthetics as long as eventually the geom part of the layer has their required aesthetics.\n\nLet's put it to the test!\n\n## Plotting sine waves\n\nI'm teaching Phonetics this semester, so I've got sine waves on the mind.\nOver a single cycle, the amplitude of sine wave of $h$ Hz can be given as\n\n$$\ny = \\sin(2hx\\pi)\n$$\n\nLet's assume I'm going to pass a `make_sine()` function with an `x` and `freq` column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_sine <- function(df){\n  df |> \n    mutate(\n      y = sin((x * freq) * (2*pi))\n    )\n}\n```\n:::\n\n\n`freq` isn't a normal aesthetic, but if I map a data column to `freq` in the ggplot aesthetic mapping, it'll get processed by the `make_sine()` function.\nI'll set up a grid of values of time by frequency with `expand_grid()` and pass it to ggplot.\nI map `time` to the x-axis and `frequency` to the `freq` \"aesthetic\" that `make_sine()` will make use of.\n\nThe important part is in `geom_line()`, where I tell it to use the `\"manual\"` aesthetic with the `make_sine()` function.\n\n\n::: {.cell renderings='[\"light\",\"dark\"]'}\n\n```{.r .cell-code}\nexpand_grid(\n  time = seq(0,1, length = 500),\n  frequency = c(1, 2, 3)\n) |> \n  ggplot(\n    aes(\n      x = time, \n      group = frequency,\n      freq = frequency\n    )\n  ) + \n    geom_line(\n      stat = \"manual\",\n      fun = make_sine\n    ) ->\n  sine_plot\n\nsine_plot\nsine_plot + theme_darkmode()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=768}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-2.png){width=768}\n:::\n:::\n\n\nVoila!\nThe `make_sine()` function calculated the y values!\nAnother fun thing is I can map the values I passed to `freq` to another aesthetic with `after_stat()`\n\n\n::: {.cell renderings='[\"light\",\"dark\"]'}\n\n```{.r .cell-code}\nsine_plot + \n  aes(color = after_stat(freq))\n\nlast_plot() + theme_darkmode()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=768}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-2.png){width=768}\n:::\n:::\n\n\nI wanted to see if I could plot some discrete Fourier transform basis functions too.\nFor this, I have two copies of the input data frame bound row-wise to each other, one with the sine functions and the other with the cosine.\nTo get the right groupings by line, I define the `group` aesthetic as well.\nI've also added in whether the function is sine or cosine.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_dft <- function(df){\n  df |> \n    mutate(\n      y = sin(2 * pi * x * freq),\n      group = str_glue(\"sin{freq}\"),\n      func = \"sin\"\n    ) |> \n    bind_rows(\n      df |> \n        mutate(\n          y = cos(2 * pi * x * freq),\n          group = str_glue(\"cos{freq}\"),\n          func = \"cos\"\n        )\n    )\n}\n```\n:::\n\n\nThe code here is basically the same as above, but I've swapped in `make_dft`.\n\n\n::: {.cell renderings='[\"light\",\"dark\"]'}\n\n```{.r .cell-code}\nexpand_grid(\n  time = seq(0,1, length = 500),\n  frequency = c(0, 1, 2)\n) |> \n  ggplot(\n    aes(time, freq = frequency)\n  )+\n  geom_line(\n    stat = \"manual\",\n    fun = make_dft\n  ) -> \n  dft_plot\n\ndft_plot\ndft_plot + theme_darkmode()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=768}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-2.png){width=768}\n:::\n:::\n\n\nAnd again, we can also map any data columns processed or created by our custom stat function to other aesthetics.\n\n\n::: {.cell renderings='[\"light\",\"dark\"]'}\n\n```{.r .cell-code}\ndft_plot +\n  aes(\n    color = after_stat(freq),\n    linetype = after_stat(func)\n  )\n\nlast_plot() + theme_darkmode()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=768}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-2.png){width=768}\n:::\n:::\n\n\n## Multi-aggregation plots\n\nI'm commonly in the situation of wanting to visualize data at multiple levels of aggregation on the same plot.\nFor example: I might want a plot of by-speaker & by-vowel means, along with a point indicating by-speaker grand means.\nPreviously, this has involved aggregating the data twice, then adding each aggregation to the plot.\n\n\n::: {.cell renderings='[\"light\",\"dark\"]'}\n\n```{.r .cell-code}\nspeaker_data |> \n  summarise(\n    .by = c(speaker, vowel),\n    across(F1:F2, mean)\n  ) ->\n  vowel_means\n\nspeaker_data |> \n  summarise(\n    .by = c(speaker),\n    across(F1:F2, mean)\n  ) ->\n  speaker_means\n\nggplot(\n  data = vowel_means,\n  aes(F2, F1, color = speaker)\n) +\n  geom_text(\n    aes(label = vowel)\n  ) +\n  geom_point(\n    data = speaker_means,\n    size = 3\n  ) +\n  scale_x_reverse() +\n  scale_y_reverse()\n\nlast_plot() + theme_darkmode()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=768}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-2.png){width=768}\n:::\n:::\n\n\nBut with the right `stat_manual()` function, we can skip this initial aggregation step.\n\nWith `make_means()`, I've made sure to summarize input data grouped by all data columns that are not `x` or `y`.\nThis will make sure that the aggregation will respect any aesthetic mapping we define in the plot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_means <- function(df){\n  df |> \n    summarise(\n      .by = matches(\"[^xy]\"),\n      across(c(x,y), mean)\n    )\n}\n```\n:::\n\n\nSo, if we use this `stat_manual()` function without defining any other aesthetic mapping, we'll get just one point in the middle of the plot at the mean of all `x` and `y` data.\n\n\n::: {.cell renderings='[\"light\",\"dark\"]'}\n\n```{.r .cell-code}\nspeaker_data |> \n  ggplot(\n    aes(F2, F1)\n  ) +\n  geom_point(\n    stat = \"manual\",\n    fun = make_means,\n    size = 5\n  ) +\n  scale_x_reverse() +\n  scale_y_reverse() \n\nlast_plot() + theme_darkmode()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=768}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-2.png){width=768}\n:::\n:::\n\n\nBut if we map `speaker` to `color`, we'll now get a point for each speaker\n\n\n::: {.cell renderings='[\"light\",\"dark\"]'}\n\n```{.r .cell-code}\nspeaker_data |> \n  ggplot(\n    aes(F2, F1)\n  ) +\n  geom_point(\n    aes(color = speaker),\n    stat = \"manual\",\n    fun = make_means,\n    size = 5\n  ) +\n  scale_x_reverse() +\n  scale_y_reverse() \n\nlast_plot() + theme_darkmode()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=768}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-2.png){width=768}\n:::\n:::\n\n\nGetting the mean for each vowel just involves adding a `geom_text()` layer and mapping `vowel` to `label`.\n\n\n::: {.cell renderings='[\"light\",\"dark\"]'}\n\n```{.r .cell-code}\nspeaker_data |> \n  ggplot(\n    aes(F2, F1)\n  ) +\n  geom_point(\n    aes(color = speaker),\n    stat = \"manual\",\n    fun = make_means,\n    size = 5\n  ) +\n  geom_text(\n    aes(\n      color = speaker,\n      label = vowel\n    ),\n    stat = \"manual\",\n    fun = make_means\n  ) +\n  scale_x_reverse() +\n  scale_y_reverse() \n\nlast_plot() + theme_darkmode()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=768}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-2.png){width=768}\n:::\n:::\n\n\nBoom!\nAll of the data aggregation happened inside the ggplot processing!\nAnd what's cool is I can change up my aesthetic mapping and the data will be re-aggregated correctly.\nThere's another vowel class coding in the `plt_vclass` column I can use instead by just mapping it to label\n\n\n::: {.cell renderings='[\"light\",\"dark\"]'}\n\n```{.r .cell-code}\nspeaker_data |> \n  ggplot(\n    aes(F2, F1)\n  ) +\n  geom_point(\n    aes(color = speaker),\n    stat = \"manual\",\n    fun = make_means,\n    size = 5\n  ) +\n  geom_text(\n    aes(\n      color = speaker,\n      label = plt_vclass\n    ),\n    stat = \"manual\",\n    fun = make_means\n  ) +\n  scale_x_reverse() +\n  scale_y_reverse() \n\nlast_plot() + theme_darkmode()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=768}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-2.png){width=768}\n:::\n:::\n\n\nI'll make a typical kind of plot you'll see at a sociolinguistics conference.\nLet's say I'm interested in whether or not the /o/ and /oh/ distributions overlap for these two speakers.\nI'll want to plot the raw data, and maybe some data ellipses, and also a label in the center of each ellipse.\n\n\n::: {.cell renderings='[\"light\",\"dark\"]'}\n\n```{.r .cell-code}\nspeaker_data |> \n  filter(\n    plt_vclass %in% c(\"o\", \"oh\")\n  ) |> \n  ggplot(\n    aes(\n      F2, F1,\n      color = speaker,\n      shape = plt_vclass\n    )\n  ) +\n  geom_point(alpha = 0.6) +\n  stat_ellipse(aes(linetype = plt_vclass)) +\n  geom_label(\n    aes(\n      label = plt_vclass,\n      linetype = plt_vclass\n    ),\n    stat = \"manual\",\n    fun = make_means,\n    show.legend = F\n  ) +\n  scale_shape_manual(\n    values = c(19, 1)\n  ) +\n  scale_y_reverse() +\n  scale_x_reverse()\n\nlast_plot() + theme_darkmode()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=768}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-2.png){width=768}\n:::\n:::\n\n\nSure, there's a lot of ggplot in there, but I didn't have to do any annoying additional aggregation to get the label positions!\n\n## Wrapping up\n\nI foresee my ggplot life getting supercharged by this.\nFor example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz_score <- function(df){\n  df |> \n    mutate(\n      .by = speaker,\n      across(c(x,y), \\(x)(x-mean(x))/sd(x))\n    )\n}\n```\n:::\n\n\n\n::: {.cell renderings='[\"light\",\"dark\"]' crop='true'}\n\n```{.r .cell-code}\nspeaker_data |> \n  ggplot(\n    aes(\n      F2, F1, \n      speaker = speaker, \n      color = speaker\n    )\n  ) +\n  geom_text(\n    aes(label = ipa_vclass),\n    stat = \"manual\",\n    fun = \\(df){df |> z_score() |> make_means()},\n    family = \"Voces\",\n    key_glyph = \"rect\"\n   ) +\n  scale_x_reverse() +\n  scale_y_reverse()+\n  coord_fixed()\n\nlast_plot() + theme_darkmode()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=768}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-2.png){width=768}\n:::\n:::\n\n\nThat's Lobanov normalization done right there in ggplot!\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}